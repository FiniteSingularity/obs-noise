uniform float4x4 ViewProj;
uniform texture2d image;

uniform float2 displace_scale;
uniform float2 uv_size;
uniform float2 pixel_size;
uniform float global_rotation;
uniform float2 global_offset;
uniform float2 sub_scaling;
uniform float2 sub_displace;
uniform float sum_influence;
uniform float time;
uniform float sub_influence;
uniform float std_scale;
uniform int layers;
uniform int noise_type;

uniform bool invert;
uniform float sub_rotation;
uniform float brightness;
uniform float contrast;

uniform bool billow;
uniform bool ridged;
uniform float power;

uniform int dw_iterations;
uniform float2 dw_strength;

#include "noise_functions.effect"

VertData mainTransform(VertData v_in)
{
	v_in.pos = mul(float4(v_in.pos.xyz, 1.0), ViewProj);
	return v_in;
}

float4 mainImage(VertData v_in) : TARGET
{
	//float3 output = float3(0.0, 0.0, 0.0);
	//float influence = 1.0;
	//float sum_influence = 0.0;
	//for (int i = 0; i < layers; i++)
	//{
	//	float layer_offset = hash33(float3(float(i), float(i), float(i))).x;
	//	float2 scale = pow(sub_scaling, float2(float(i), float(i)));
		
	//	float3 c = sample_noise(v_in.uv, i, scale);
	//	c = map_noise(c);
	//	output += c * influence;
	//	sum_influence += influence;
	//	influence *= sub_influence;
	//}
	//output = output / sum_influence;
	//output.rgb = adjustments(float4(output, 1.0), brightness, contrast);
	//float2 offset = 2.0 * (output.rg - 0.5) * displace_scale;
	//return image.Sample(textureSampler, v_in.uv + (offset / uv_size));
	
	// 1. Get first pass of fractal noise
	float2 uv = transform(v_in.uv, float2(0.5, 0.5), global_rotation);
	float3 output = fractal_noise(uv);
	// 2. Apply Domain Warping
	float2 dw_shift = float2(9.5f, 10.2f);
	for (int i = 0; i < dw_iterations; i++)
	{
		output = fractal_noise(uv + dw_strength * 2.0f * (output.xy - 0.5f) / uv_size + dw_shift);
		dw_shift += 10.0f;
	}

	// 3. Prepare and return pixel output
	output.rgb = adjustments(float4(output, 1.0), brightness, contrast);
	// Scale 0-1 output to -1 to 1, then multiple by displace scale 
	float2 offset = 2.0 * (output.rg - 0.5) * displace_scale;
	return image.Sample(textureSampler, v_in.uv + (offset / uv_size));
}

technique Draw
{
	pass
	{
		vertex_shader = mainTransform(v_in);
		pixel_shader = mainImage(v_in);
	}
}

//technique DrawMax
//{
//	pass
//	{
//		vertex_shader = mainTransform(v_in);
//		pixel_shader = mainImageMax(v_in);
//	}
//}
